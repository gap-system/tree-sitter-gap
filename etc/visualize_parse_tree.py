#!/usr/bin/env python3
"""Script to visualize parse trees generated by `tree-sitter-gap`

Make sure to run `python3 -m pip install .` in the project root to install the
python bindings for the development version of the `tree-sitter-gap` grammar.
"""

import argparse
import tree_sitter_gap as tsgap
from tree_sitter import Language, Parser, Tree, Node
import pydot


def traverse_tree(tree: Tree):
    cursor = tree.walk()

    nodes: list[Node] = []
    idx_of: dict[Node, int] = {}
    visited_children = False
    while True:
        if not visited_children:
            node = cursor.node
            assert node is not None
            idx_of[node] = len(nodes)
            nodes.append(node)
            if not cursor.goto_first_child():
                visited_children = True
        elif cursor.goto_next_sibling():
            visited_children = False
        elif not cursor.goto_parent():
            break

    return nodes, idx_of


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Visualize the parse tree of a file, outputs svg"
    )
    parser.add_argument(
        "-i",
        "--in_file",
        type=str,
        default=None,
        help="Name of the file to process. If omitted, input is taken from stdin instead.",
        required=False,
    )
    parser.add_argument(
        "-o",
        "--out_file",
        type=str,
        help="Name of the output file.",
    )
    args = parser.parse_args()

    GAP_LANGUAGE = Language(tsgap.language())
    parser = Parser(GAP_LANGUAGE)

    if args.in_file is None:
        text = input().encode("utf-8")
    else:
        with open(args.in_file, "rb") as in_file:
            text = in_file.read()

    tree = parser.parse(text)
    nodes, idx_of = traverse_tree(tree)

    dot = pydot.Dot(graph_name="D", graph_type="digraph")
    for node_idx, node in enumerate(nodes):
        if not node.is_named:
            continue
        else:
            dot.add_node(
                pydot.Node(
                    f"node_{node_idx}",
                    label=node.type,
                )
            )

    for node_idx, node in enumerate(nodes):
        for relative_idx, child in enumerate(node.children):
            child_idx = idx_of[child]
            if not node.is_named or not child.is_named:
                continue
            field = node.field_name_for_child(relative_idx)
            if field is None:
                dot.add_edge(pydot.Edge(f"node_{node_idx}", f"node_{child_idx}"))
            else:
                dot.add_edge(
                    pydot.Edge(
                        f"node_{node_idx}", f"node_{child_idx}", label=f"{field}"
                    )
                )

    dot.write_svg(args.out_file, prog="dot")
